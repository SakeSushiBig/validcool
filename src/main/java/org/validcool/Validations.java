package org.validcool;

import java.util.Arrays;
import java.util.Collection;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.regex.Pattern;

public class Validations {

    /**
     * Central point of validation for the validcool library.
     */
    public static final ValidcoolConfiguration validcoolConfig = new ValidcoolConfiguration();

    /**
     * Executes the specified validator with the actual value. Then it will use the configured handling function iff
     * an invalid result occurs. By default this will trigger a ValidationException with an autogenerated error message.
     */
    public static <E> void validate(E actual, Validator<E> validator) {
        validator.apply(actual);
        if(!validator.isValid()) {
            String errorMessage = validator.getErrorMessage();
            validcoolConfig.handle(errorMessage);
        }
    }

    /**
     * Executes the specified validator with the actual value. It will trigger the configured logging mechanism iff enabled,
     * and return true iff the validation was successful.
     */
    public static <E> boolean check(E actual, Validator<E> validator) {
        validator.apply(actual);
        boolean isValid = validator.isValid();
        if(!isValid) {
            validcoolConfig.logIfEnabled(validator.getErrorMessage());
        }
        return isValid;
    }

    /**
     * Allows to perform a validator on a property or calculated value from the actual. This is very useful when validating
     * properties of objects like in this example:
     * <code>
     *     validate(person, with(Person::getAge, greaterThan(17)).and(with(Person::getGender, equalTo("m")));
     * </code>
     */
    public static <E, S> Validator<E> with(Function<E, S> selector, Validator<S> validator) {
        return new Validator<>(
                (E value) -> {
                    validator.apply(selector.apply(value));
                    return validator.isValid();
                },
                validator.getDescription(),
                (E value) -> validator.getErrorMessage()
        );
    }

    /**
     * Fails when actual value is not null.
     */
    public static <E> Validator<E> nullValue() {
        return new Validator<>(
                (E value) -> value == null,
                "null value",
                (E value) -> String.format("Expected null value but got: \"%s\".", value)
        );
    }

    /**
     * Can be used to negate any validator construct. For example:
     * <code>
     *     validate(result, not(nullValue()));
     * </code>
     */
    public static <E> Validator<E> not(Validator<E> validator) {
        return new Validator<>(
                (E value) -> {
                    validator.apply(value);
                    return !validator.isValid();
                },
                "not",
                (E value) -> String.format("Expected not %s but got: \"%s\".", validator.getDescription(), value)
        );
    }

    /**
     * Fails when the actual value is not contained in the specified collection.
     * The collection must not be null.
     */
    public static <E> Validator<E> in(Collection<E> items) {
        return new Validator<>(
                items::contains,
                "in",
                (E value) -> String.format("%s is not in %s", value, Arrays.toString(items.toArray()))
        );
    }

    public static <E extends Comparable<E>> Validator<E> greaterThan(E other) {
        return new Validator<>(
                (E value) -> value.compareTo(other) > 0,
                String.format("greater than \"%s\"", other),
                (E value) -> String.format("\"%s\" is not greater than \"%s\"", value, other)
        );
    }

    public static <E extends Comparable<E>> Validator<E> lowerThan(E other) {
        return new Validator<>(
                (E value) -> value.compareTo(other) < 0,
                String.format("lower than \"%s\"", other),
                (E value) -> String.format("\"%s\" is not lower than \"%s\"", value, other)
        );
    }

    public static <E> Validator<E> equalTo(E other) {
        return new Validator<>(
                (E value) -> value.equals(other),
                String.format("equal to \"%s\"", other),
                (E value) -> String.format("\"%s\" is not equal to \"%s\"", value, other)
        );
    }

}
